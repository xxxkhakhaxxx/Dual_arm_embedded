/**
 ********************************************************************************
 ** @file    AppCommCAN.c
 ** @author  HH (hunghoang.1806@gmail.com)
 ** @date    Oct 30, 2024 (created)
 ** @brief   
 ********************************************************************************
 **/

/********************************************************************************
 * INCLUDES
 ********************************************************************************/
#include "AppCommCAN.h"

/********************************************************************************
 * EXTERN VARIABLES
 ********************************************************************************/


/********************************************************************************
 * PRIVATE MACROS AND DEFINES
 ********************************************************************************/


/********************************************************************************
 * PRIVATE TYPEDEFS AND ENUMS
 ********************************************************************************/


/********************************************************************************
 * PRIVATE VARIABLES
 ********************************************************************************/
PRIVATE CAN_HandleTypeDef* strCanUse;

PRIVATE CAN_TxHeaderTypeDef strCanTxMsgId;		// Tx message ID - header
PRIVATE CAN_RxHeaderTypeDef strCanRxMsgId;		// Rx message ID - header

PRIVATE U08 arrCanTxMsgData[MOTOR_PROTOCOL_DATA_FRAME_LENGTH] = {0, };	// Tx data
PRIVATE U08 arrCanRxMsgData[MOTOR_PROTOCOL_DATA_FRAME_LENGTH] = {0, };	// Rx data

PRIVATE U32 u32CanTxMsgMailBox = 0;				// Tx header and data

/* Debug view variable */
volatile static U32 debug_cnt_Rx_Ok = 0;
volatile static U32 debug_cnt_Rx_Error = 0;
volatile static U32 debug_cnt_Tx_Ok = 0;
volatile static U32 debug_cnt_Tx_Error = 0;
volatile static U32 debug_cnt_Tx_ErrorParam = 0;
volatile static U32 debug_cnt_Tx_ErrorInit = 0;
/********************************************************************************
 * GLOBAL VARIABLES
 ********************************************************************************/


/********************************************************************************
 * PRIVATE FUNCTION DECLARATION
 ********************************************************************************/
PRIVATE void AppCommCAN_SetupFilter(void);
PRIVATE void AppCommCAN_SetupRxInterrupt(void);
PRIVATE void AppCommCAN_SetupTxFrame(void);
PRIVATE void AppCommCAN_ClearTxMailBox(void);
/********************************************************************************
 * PRIVATE FUNCTION IMPLEMENTATION
 ********************************************************************************/
//PRIVATE void AppCommCAN_SetupFilter(CAN_HandleTypeDef *hcan)
//{
//	strCanFilterId.FilterActivation		= CAN_FILTER_DISABLE;
////	strCanFilterId.FilterActivation		= CAN_FILTER_ENABLE;
//	strCanFilterId.FilterBank			= 1;
//	strCanFilterId.FilterFIFOAssignment	= CAN_FILTER_FIFO0;
//	strCanFilterId.FilterIdHigh			= 0x0020 << 5;
//	strCanFilterId.FilterIdLow			= 0x0000;
//	strCanFilterId.FilterMaskIdHigh		= 0xffdf << 5;
//	strCanFilterId.FilterMaskIdLow		= 0x0000;
//	strCanFilterId.FilterMode			= CAN_FILTERMODE_IDMASK;
//	strCanFilterId.FilterScale			= CAN_FILTERSCALE_32BIT;
//	strCanFilterId.SlaveStartFilterBank	= 1;
//
//	if (HAL_CAN_ConfigFilter(hcan, &strCanFilterId) != HAL_OK) // hcan is the address of the can generated by CubeIde
//	{
////		Error_Handler();
//	}
//}

PRIVATE void AppCommCAN_SetupFilter(void)
{
    CAN_FilterTypeDef canFilterIdConfig;					// User CAN filter ID - header filter

    // First filter for 0x140 to 0x160 (Single motor ID 1~32, 0 is for user)
    canFilterIdConfig.FilterBank = 0;
    canFilterIdConfig.FilterMode = CAN_FILTERMODE_IDMASK;
    canFilterIdConfig.FilterScale = CAN_FILTERSCALE_32BIT;
    canFilterIdConfig.FilterIdHigh = 0x140 << 5;			// 11-bit ID shifted to the correct position
    canFilterIdConfig.FilterIdLow = 0x0000;
    canFilterIdConfig.FilterMaskIdHigh = 0x7E0 << 5;		// Mask to match IDs from 0x140 to 0x160
    canFilterIdConfig.FilterMaskIdLow = 0x0000;
    canFilterIdConfig.FilterFIFOAssignment = CAN_FILTER_FIFO0;
    canFilterIdConfig.FilterActivation = CAN_FILTER_ENABLE;
    canFilterIdConfig.SlaveStartFilterBank = 1;

    if (HAL_CAN_ConfigFilter(strCanUse, &canFilterIdConfig) != HAL_OK)
    {
        // Error_Handler();
    }

    // Second filter for 0x280 (Multi-motor)
    canFilterIdConfig.FilterBank = 1;
    canFilterIdConfig.FilterMode = CAN_FILTERMODE_IDMASK;
    canFilterIdConfig.FilterScale = CAN_FILTERSCALE_32BIT;
    canFilterIdConfig.FilterIdHigh = 0x280 << 5; // Exact ID
    canFilterIdConfig.FilterIdLow = 0x0000;
    canFilterIdConfig.FilterMaskIdHigh = 0x7FF << 5; // Full mask for exact match
    canFilterIdConfig.FilterMaskIdLow = 0x0000;
    canFilterIdConfig.FilterFIFOAssignment = CAN_FILTER_FIFO0;
    canFilterIdConfig.FilterActivation = CAN_FILTER_ENABLE;
    canFilterIdConfig.SlaveStartFilterBank = 1;

    if (HAL_CAN_ConfigFilter(strCanUse, &canFilterIdConfig) != HAL_OK)
    {
        // Error_Handler();
    }
}


PRIVATE void AppCommCAN_SetupRxInterrupt(void)
{
	if (HAL_OK != HAL_CAN_ActivateNotification(strCanUse, CAN_IT_RX_FIFO0_MSG_PENDING))	// Active Rx for FIFO0
	{
//		Error_Handler();
	}
}

PRIVATE void AppCommCAN_SetupTxFrame(void)
{
	/* Not change value */
	strCanTxMsgId.IDE = CAN_ID_STD;		// Use CAN A - ID frame 11 bits
	strCanTxMsgId.RTR = CAN_RTR_DATA;	// Use Data frame
	strCanTxMsgId.DLC = 0x08;			// Data is 8 bytes

	/* Change value */
//	strCanTxMsgId.StdId = MOTOR_1_ID;	// Not here, set in send function
}

PRIVATE void AppCommCAN_ClearTxMailBox(void)
{
	uint32_t freeLevel = HAL_CAN_GetTxMailboxesFreeLevel(strCanUse);

	// Check if all mailboxes are full
	if (freeLevel == 0)
	{
		// Abort all pending transmissions
		HAL_CAN_AbortTxRequest(strCanUse, CAN_TX_MAILBOX0);
		HAL_CAN_AbortTxRequest(strCanUse, CAN_TX_MAILBOX1);
		HAL_CAN_AbortTxRequest(strCanUse, CAN_TX_MAILBOX2);

		// Clear data registers
		strCanUse->Instance->sTxMailBox[CAN_TX_MAILBOX0].TIR = 0;
		strCanUse->Instance->sTxMailBox[CAN_TX_MAILBOX0].TDTR = 0;
		strCanUse->Instance->sTxMailBox[CAN_TX_MAILBOX0].TDLR = 0;
		strCanUse->Instance->sTxMailBox[CAN_TX_MAILBOX0].TDHR = 0;
		strCanUse->Instance->sTxMailBox[CAN_TX_MAILBOX1].TIR = 0;
		strCanUse->Instance->sTxMailBox[CAN_TX_MAILBOX1].TDTR = 0;
		strCanUse->Instance->sTxMailBox[CAN_TX_MAILBOX1].TDLR = 0;
		strCanUse->Instance->sTxMailBox[CAN_TX_MAILBOX1].TDHR = 0;
		strCanUse->Instance->sTxMailBox[CAN_TX_MAILBOX2].TIR = 0;
		strCanUse->Instance->sTxMailBox[CAN_TX_MAILBOX2].TDTR = 0;
		strCanUse->Instance->sTxMailBox[CAN_TX_MAILBOX2].TDLR = 0;
		strCanUse->Instance->sTxMailBox[CAN_TX_MAILBOX2].TDHR = 0;

	}
}

/********************************************************************************
 * GLOBAL FUNCTION IMPLEMENTATION
 ********************************************************************************/
/**
  * @brief  Cấu hình những thứ cần thiết để chạy CAN
  * @author Hung Hoang (hunghoang.1806@gmail.com)
  * @param  hcan: con trỏ tới biến CAN mà do CubeIDE tạo ra,
  *               nếu là STM32F1xx thì là "hcan" (do chỉ có 1 kênh CAN),
  *               nếu là STM32F4xx thì là "hcan1" hoặc "hcan2" (có 2 kênh CAN)
  * @proces 1/ Thiết lập CAN Filter
  *         2/ Thiết lập dùng ngắt
  *         3/ Thiết lập Tx frame
  *         4/ Sau khi chạy hàm này, user có thể start CAN ở hàm main bằng hàm "HAL_CAN_Start(&hcan?)"
  * @retval None
  */
GLOBAL void AppCommCAN_UserSetup(CAN_HandleTypeDef *hcan)
{
	strCanUse = hcan;				// Save this for private function can be use
	AppCommCAN_SetupFilter();
	AppCommCAN_SetupRxInterrupt();	// Enable interrupt
	AppCommCAN_SetupTxFrame();		// Setting for Tx message ID
}

GLOBAL void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)	// When Rx interrupt occur
{
	if (HAL_OK != HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &strCanRxMsgId, arrCanRxMsgData))	// Get MsgId and Data
	{
//		Error_Handler();
		debug_cnt_Rx_Error++;
	}
	else	// No error
	{
		AppDataSet_CanRxMsgFlag(TRUE);
		debug_cnt_Rx_Ok++;
	}
}

GLOBAL void AppCommCAN_SendMotorMessage(U08 _u8MotorMsgId, U08 _u8MsgDataCmd)
{
	// Set Tx identifier
	strCanTxMsgId.StdId = (U32)(MOTOR_PROTOCOL_GET_HEADER(_u8MotorMsgId));

	// Set Tx data to buffer
	ApiProtocolMotorMG_TxHandler(_u8MotorMsgId, _u8MsgDataCmd, arrCanTxMsgData);

	// Send Tx data
	if (HAL_OK == HAL_CAN_AddTxMessage(strCanUse, &strCanTxMsgId, arrCanTxMsgData, &u32CanTxMsgMailBox))
	{
		debug_cnt_Tx_Ok++;
	}
	else	// HAL_ERROR
	{
		debug_cnt_Tx_Error++;
		if (HAL_CAN_ERROR_PARAM == (strCanUse->ErrorCode & HAL_CAN_ERROR_PARAM))
		{	// Tx Mailbox full
			debug_cnt_Tx_ErrorParam++;
			AppCommCAN_ClearTxMailBox();
		}
		else	// HAL_CAN_ERROR_NOT_INITIALIZED
		{
			debug_cnt_Tx_ErrorInit++;
		}
	}
}

GLOBAL void AppCommCAN_GetMotorMessage(void)	// Process data in "strCanRxMsgId" and "arrCanRxMsgData"
{
	ApiProtocolMotorMG_RxHandler(strCanRxMsgId.StdId, arrCanRxMsgData);
	// Here, you can call any other function to handle the message ID and DATA
}
